(import ast)
(import argparse)
(import io)
(import os)
(import os.path as osp)
(import runpy)
(import sys)

(import black)
(import isort)

(from sxpy.core.parser [parse])
(from sxpy.core.macro [macroexpand-then-compile])



;;; temporary macro definitions. later, should be imported or required from another file like macros.sy

(defmacro cond [*body]
  (def recur [*body]
    (if (< (len body) 4)
        (return `(if ~@body))
        (do (= [test then *orelse] body)
            (return `(if ~test ~then ~(recur *orelse))))))
  (return (recur *body)))

(defmacro -> [x *fs]
  (if (== 0 (len fs))
      (return x))
  (= [f *rest] fs)
  (if (isinstance f Paren)
      (do (f.list.insert 1 x)
          (return `(-> ~f ~@rest)))
      (return `(-> (~f ~x) ~@rest))))

;;; macro definitions end


(def ast-to-python [st]
  (return (str (ast.unparse st))))

(def src-to-python [src]
  (return (.join "\n" (map ast-to-python
                           (macroexpand-then-compile
                             (parse src))))))

(def black-src [src]
  (return (.rstrip (black.format-str src :mode (black.FileMode)) "\n")))

(= argparser (argparse.ArgumentParser))
(argparser.add-argument "filename" :nargs "?" :default "")
(argparser.add-argument "-t" "--translate"
                        :dest "translate"
                        :action "store_true"
                        :default False)
(argparser.add-argument "-m"
                        :dest "module_name"
                        :action "store")

(def transcompile []
  (= args (argparser.parse-args))
  (= file (osp.join (os.getcwd) args.filename))
  (with [(open file "rb") as f]
    (= org (.decode (f.read) "utf-8")))
  (= blacked (black-src (src-to-python org)))
  (= isorted (isort.code blacked))
  (print isorted))

(def _is-sy-file [filename]
  (return (and (osp.isfile filename)
               (== (sub (osp.splitext filename) 1) ".sy"))))

;;; runpy injection
(def inject-runpy []
  (= _org-get-code-from-file runpy._get-code-from-file)

  (def _get-sy-code-from-file [run-name fname]
    (from pkgutil [read-code])
    (= decoded-path (osp.abspath (os.fsdecode fname)))

    (with [(io.open-code decoded-path) as f]
      (= code (read-code f)))

    (if (is code None)
        (if (_is-sy-file fname)
            (do (with [(open decoded-path "rb") as f]
                  (= src (.decode (f.read) "utf-8")))
                (= parsed (parse src))
                (= ast-module (ast.Module (macroexpand-then-compile parsed)
                                          :type-ignores []))
                (= code (compile ast-module fname "exec")))
            (= code (sub (_org-get-code-from-file run-name fname) 0))))
    (return [code fname]))

  (= runpy._get-code-from-file _get-sy-code-from-file))

(def repl [translate]
  (while True
    (= line (input "repl > \n"))
    (= src "")
    (while (!= line "")
      (+= src (+ "\n" line))
      (= line (input "")))
    (try
      (do (= parsed (parse src))
          (= stl (macroexpand-then-compile parsed))
          (if translate
              (do (print "python translation")
                  (print (.join "\n" (list (map ast-to-python stl))))
                  (print "")))
          (print "result")
          (for st stl
            (eval (compile (ast.Interactive :body [st]) "" "single")
                  (globals)))
          (print "\n"))
      (except [Exception as e]
        (raise e)
        (print "Exception: " e)))))

(def run []
  (= args (argparser.parse-args))

  ;; remove options from sys.argv
  (= argv sys.argv)
  (= option-removed [])
  (while argv
    (if (.startswith (:= larg (argv.pop)) "-")
        (= option-removed [])
        (option-removed.append larg)))
  (while option-removed
    (argv.append (option-removed.pop)))
  
  (cond (:= fname args.filename)
        (runpy.run-path fname :run-name "__main__")

        (:= mname args.module-name)
        (runpy.run-module mname :run-name "__main__" :alter-sys True)

        (repl args.translate)))
