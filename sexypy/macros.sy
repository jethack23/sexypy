;; return redifinable here
(defmacro return-compile [sexp]
  (:= value (sub sexp.list 1))
  (return (ast.Return :value (expr-compile value)
                      **sexp.position-info)))

(defmacro =-compile [sexp]
  (:= targets sexp.operands)
  (:= value (targets.pop))
  (return (ast.Assign
            :targets (list (map (lambda [x] (expr-compile x :ctx ast.Store)) targets))
            :value (expr-compile value)
            **sexp.position-info)))

(defmacro if-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.If :test (expr-compile test)
                  :body (macroexpand-then-compile [then])
                  :orelse (macroexpand-then-compile [orelse])
                  **sexp.position-info)))

(defmacro def-compile [sexp :decorator-list None]
  (= [_ fnname args *body] sexp.list)
  (if (and body (== (sub body 0) ":->"))
      (= [_ returns *body] body)
      (= returns None))
  (return (ast.FunctionDef
            :name fnname.name
            :args (def-args-parse args)
            :body (macroexpand-then-compile body)
            :decorator-list (ife decorator-list
                                 (list (map expr-compile decorator-list))
                                 [])
            :returns (ife returns (expr-compile returns) None)
            **sexp.position-info)))

(defmacro do-compile [sexp]
  (= [_ *sexps] sexp.list)
  (return (macroexpand-then-compile sexps)))

(defmacro del-compile [sexp]
  (= [_ *args] sexp.list)
  (return (ast.Delete
            :targets (list (map (lambda [x] (expr-compile x ast.Del))
                                args))
            **sexp.position-info)))

(defmacro pass-compile [sexp]
  (return (ast.Pass **sexp.position-info)))

(defmacro import-compile [sexp]
  (= [_ *names] sexp.list)
  (return (ast.Import
            :names (list (map (lambda [x] (ast.alias x.name
                                                     **x.position-info))
                              names))
            **sexp.position-info)))

(defmacro from-compile [sexp]
  (= [_ *args] sexp.list)
  (= modules (sub args [: _ _ 2]))
  (= namess (sub args [: 1 _ 2]))
  (return
    (list
      (map
        (lambda
          [pair]
          ((lambda
             [m ns]
             (ast.ImportFrom
               :module m.name
               :names (list (map (lambda [x] (ast.alias
                                               x.name
                                               **x.position-info))
                                 ns.list))
               **(merge-position-infos
                   m.position-info
                   ns.position-info)))
            *pair))
        (zip modules namess)))))

(defmacro while-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.While :test (expr-compile test)
                     :body (macroexpand-then-compile [then])
                     :orelse (macroexpand-then-compile [orelse])
                     **sexp.position-info)))

(defmacro for-compile [sexp]
  (= [_ target iterable body orelse] (ife (< (len sexp.list) 5)
                                          [*sexp.list None]
                                          sexp.list))
  (return (ast.For :target (expr-compile target ast.Store)
                   :iter (expr-compile iterable)
                   :body (macroexpand-then-compile [body])
                   :orelse (macroexpand-then-compile [orelse])
                   **sexp.position-info)))

(defmacro break-compile [sexp]
  (return (ast.Break **sexp.position-info)))

(defmacro continue-compile [sexp]
  (return (ast.Continue **sexp.position-info)))

(defmacro deco-compile [sexp :decorator-list None]
  (= [op decorator def-statement] sexp.list)
  (= new-deco-list (ife (isinstance decorator Bracket)
                        decorator.list
                        [decorator]))
  (return `(def-compile
             ~def-statement
             ~(+ (ife decorator-list decorator-list []) new-deco-list))))

(do (defmacro augassign-generator []
      (= augassignop-dict {"+=" 'ast.Add
                           "-=" 'ast.Sub
                           "*=" 'ast.Mult
                           "/=" 'ast.Div
                           "//=" 'ast.FloorDiv
                           "%=" 'ast.Mod
                           "**=" 'ast.Pow
                           "<<=" 'ast.LShift
                           ">>=" 'ast.RShift
                           "|=" 'ast.BitOr
                           "^=" 'ast.BitXor
                           "&=" 'ast.BitAnd
                           "@=" 'ast.MatMult})
      (def augassign-compile [opname astop]
        (return `(defmacro ~(Symbol (+ opname "-compile")) [sexp]
                   (= [op target *args] sexp.list)
                   (= value (reduce (lambda [x y] (ast.Binop x (~astop) y
                                                             **(merge-position-infos
                                                                 op.position-info
                                                                 y.position-info)))
                                    (map expr-compile args)))
                   (return (ast.AugAssign :target (expr-compile target ast.Store)
                                          :op (~astop)
                                          :value value
                                          **sexp.position-info)))))

      (return `(do ~@(map (lambda [x] (augassign-compile *x))
                          (augassignop-dict.items)))))
    (augassign-generator))

(defmacro global-compile [sexp]
  (= [_ *args] sexp.list)
  (return (ast.Global :names (list (map (lambda [x] x.name) args))
                      **sexp.position-info)))

(defmacro nonlocal-compile [sexp]
  (= [_ *args] sexp.list)
  (return (ast.Nonlocal :names (list (map (lambda [x] x.name) args))
                        **sexp.position-info)))

(defmacro class-compile [sexp :decorator-list None]
  (def classdef-args-parse [args]
    (= q (deque args))
    (= bases [])
    (= keywords [])
    (while q
      (if (isinstance (:= arg (q.popleft)) Keyword)
          (keywords.append (ast.keyword :arg arg.name
                                        :value (expr-compile (:= value (q.popleft)))
                                        **(merge-position-infos arg.position-info value.position-info)))
          (bases.append (expr-compile arg))))
    (return [bases keywords]))
  (= [_ clsname args *body] sexp.list)
  (= [bases keywords] (classdef-args-parse args))
  (return (ast.ClassDef
            :name clsname.name
            :bases bases
            :keywords keywords
            :body (macroexpand-then-compile body)
            :decorator-list (ife decorator-list
                                 (list (map expr-compile decorator-list))
                                 [])
            **sexp.position-info)))
