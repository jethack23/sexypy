(defmacro =-compile [sexp]
  (:= [op *targets value] sexp.list)
  (return (ast.Assign
            :targets (list (map (lambda [x] (expr-compile x :ctx ast.Store)) targets))
            :value (expr-compile value)
            **sexp.position-info)))

(defmacro if-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.If :test (expr-compile test)
                  :body (macroexpand-then-compile [then])
                  :orelse (macroexpand-then-compile [orelse])
                  **sexp.position-info)))

(defmacro while-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.While :test (expr-compile test)
                     :body (macroexpand-then-compile [then])
                     :orelse (macroexpand-then-compile [orelse])
                     **sexp.position-info)))

(defmacro for-compile [sexp]
  (= [_ target iterable body orelse] (ife (< (len sexp.list) 5)
                                          [*sexp.list None]
                                          sexp.list))
  (return (ast.For :target (expr-compile target ast.Store)
                   :iter (expr-compile iterable)
                   :body (macroexpand-then-compile [body])
                   :orelse (macroexpand-then-compile [orelse])
                   **sexp.position-info)))

(defmacro break-compile [sexp]
  (return (ast.Break **sexp.position-info)))

(defmacro continue-compile [sexp]
  (return (ast.Continue **sexp.position-info)))

(defmacro def-compile [sexp :decorator-list None]
  (= [_ fnname args *body] sexp.list)
  (if (and body (== (sub body 0) ":->"))
      (= [_ returns *body] body)
      (= returns None))
  (return (ast.FunctionDef
            :name fnname.name
            :args (def-args-parse args)
            :body (macroexpand-then-compile body)
            :decorator-list (ife decorator-list
                                 (list (map expr-compile decorator-list))
                                 [])
            :returns (ife returns (expr-compile returns) None)
            **sexp.position-info)))
