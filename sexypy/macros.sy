(defmacro =-compile [sexp]
  (:= [op *targets value] sexp.list)
  (return (ast.Assign
            :targets (list (map (lambda [x] (expr-compile x :ctx ast.Store)) targets))
            :value (expr-compile value)
            **sexp.position-info)))

(defmacro if-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.If :test (expr-compile test)
                  :body (macroexpand-then-compile [then])
                  :orelse (macroexpand-then-compile [orelse])
                  **sexp.position-info)))

(defmacro while-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.While :test (expr-compile test)
                     :body (macroexpand-then-compile [then])
                     :orelse (macroexpand-then-compile [orelse])
                     **sexp.position-info)))

(defmacro for-compile [sexp]
  (= [_ target iterable body orelse] (ife (< (len sexp.list) 5)
                                          [*sexp.list None]
                                          sexp.list))
  (return (ast.For :target (expr-compile target ast.Store)
                   :iter (expr-compile iterable)
                   :body (macroexpand-then-compile [body])
                   :orelse (macroexpand-then-compile [orelse])
                   **sexp.position-info)))

(defmacro break-compile [sexp]
  (return (ast.Break **sexp.position-info)))

(defmacro continue-compile [sexp]
  (return (ast.Continue **sexp.position-info)))
