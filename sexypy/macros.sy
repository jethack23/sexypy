;;; return redifinable here
;; (defmacro return-compile [sexp]
;;   (:= [_ value] sexp.list)
;;   (return (ast.Return :value (expr-compile value)
;;                       **sexp.position-info)))

(defmacro =-compile [sexp]
  (:= [op *targets value] sexp.list)
  (return (ast.Assign
            :targets (list (map (lambda [x] (expr-compile x :ctx ast.Store)) targets))
            :value (expr-compile value)
            **sexp.position-info)))

(defmacro if-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.If :test (expr-compile test)
                  :body (macroexpand-then-compile [then])
                  :orelse (macroexpand-then-compile [orelse])
                  **sexp.position-info)))

(defmacro while-compile [sexp]
  (= [_ test then orelse] (ife (< (len sexp.list) 4)
                               [*sexp.list None]
                               sexp.list))
  (return (ast.While :test (expr-compile test)
                     :body (macroexpand-then-compile [then])
                     :orelse (macroexpand-then-compile [orelse])
                     **sexp.position-info)))

(defmacro for-compile [sexp]
  (= [_ target iterable body orelse] (ife (< (len sexp.list) 5)
                                          [*sexp.list None]
                                          sexp.list))
  (return (ast.For :target (expr-compile target ast.Store)
                   :iter (expr-compile iterable)
                   :body (macroexpand-then-compile [body])
                   :orelse (macroexpand-then-compile [orelse])
                   **sexp.position-info)))

(defmacro break-compile [sexp]
  (return (ast.Break **sexp.position-info)))

(defmacro continue-compile [sexp]
  (return (ast.Continue **sexp.position-info)))

(defmacro def-compile [sexp :decorator-list None]
  (= [_ fnname args *body] sexp.list)
  (if (and body (== (sub body 0) ":->"))
      (= [_ returns *body] body)
      (= returns None))
  (return (ast.FunctionDef
            :name fnname.name
            :args (def-args-parse args)
            :body (macroexpand-then-compile body)
            :decorator-list (ife decorator-list
                                 (list (map expr-compile decorator-list))
                                 [])
            :returns (ife returns (expr-compile returns) None)
            **sexp.position-info)))

(defmacro deco-compile [sexp :decorator-list None]
  (= [op decorator def-statement] sexp.list)
  (= new-deco-list (ife (isinstance decorator Bracket)
                        decorator.list
                        [decorator]))
  (return `(def-compile
             ~def-statement
             ~(+ (ife decorator-list decorator-list []) new-deco-list))))

(defmacro global-compile [sexp]
  (= [_ *args] sexp.list)
  (return (ast.Global :names (list (map (lambda [x] x.name) args))
                      **sexp.position-info)))

(defmacro nonlocal-compile [sexp]
  (= [_ *args] sexp.list)
  (return (ast.Nonlocal :names (list (map (lambda [x] x.name) args))
                        **sexp.position-info)))

(defmacro class-compile [sexp :decorator-list None]
  (def classdef-args-parse [args]
    (= q (deque args))
    (= bases [])
    (= keywords [])
    (while q
      (if (isinstance (:= arg (q.popleft)) Keyword)
          (keywords.append (ast.keyword :arg arg.name
                                        :value (expr-compile (:= value (q.popleft)))
                                        **(merge-position-infos arg.position-info value.position-info)))
          (bases.append (expr-compile arg))))
    (return [bases keywords]))
  (= [_ clsname args *body] sexp.list)
  (= [bases keywords] (classdef-args-parse args))
  (return (ast.ClassDef
            :name clsname.name
            :bases bases
            :keywords keywords
            :body (macroexpand-then-compile body)
            :decorator-list (ife decorator-list
                                 (list (map expr-compile decorator-list))
                                 [])
            **sexp.position-info)))
